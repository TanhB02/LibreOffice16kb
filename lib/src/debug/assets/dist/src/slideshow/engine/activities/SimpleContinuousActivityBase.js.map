{"version":3,"file":"SimpleContinuousActivityBase.js","sourceRoot":"","sources":["../../../../../../../../../../../../TanhX/online/browser/src/slideshow/engine/activities/SimpleContinuousActivityBase.ts"],"names":[],"mappings":"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","sourcesContent":["/* -*- js-indent-level: 8 -*- */\n\n/*\n * Copyright the Collabora Online contributors.\n *\n * SPDX-License-Identifier: MPL-2.0\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at http://mozilla.org/MPL/2.0/.\n */\n\nabstract class SimpleContinuousActivityBase extends ActivityBase {\n\tprivate aTimer: ElapsedTime;\n\tprotected nMinSimpleDuration: number;\n\tprivate nMinNumberOfFrames: number;\n\tprotected nCurrPerformCalls: number;\n\tconstructor(aCommonParamSet: ActivityParamSet) {\n\t\tsuper(aCommonParamSet);\n\n\t\t// Time elapsed since activity started\n\t\tthis.aTimer = new ElapsedTime(aCommonParamSet.aActivityQueue.getTimer());\n\t\t// Simple duration of activity\n\t\tthis.nMinSimpleDuration = aCommonParamSet.nMinDuration;\n\t\t// Minimal number of frames to show\n\t\tthis.nMinNumberOfFrames = aCommonParamSet.nMinNumberOfFrames;\n\t\t// Actual number of frames shown until now.\n\t\tthis.nCurrPerformCalls = 0;\n\t}\n\n\tpublic startAnimation() {\n\t\t// init timer. We measure animation time only when we're\n\t\t// actually started.\n\t\tthis.aTimer.reset();\n\t}\n\n\tpublic calcTimeLag() {\n\t\tsuper.calcTimeLag();\n\n\t\tif (!this.isActive()) return 0.0;\n\n\t\t// retrieve locally elapsed time\n\t\tconst nCurrElapsedTime = this.aTimer.getElapsedTime();\n\n\t\t// go to great length to ensure a proper animation\n\t\t// run. Since we don't know how often we will be called\n\t\t// here, try to spread the animator calls uniquely over\n\t\t// the [0,1] parameter range. Be aware of the fact that\n\t\t// perform will be called at least mnMinNumberOfTurns\n\t\t// times.\n\n\t\t// fraction of time elapsed\n\t\tconst nFractionElapsedTime = nCurrElapsedTime / this.nMinSimpleDuration;\n\n\t\t// fraction of minimum calls performed\n\t\tconst nFractionRequiredCalls =\n\t\t\tthis.nCurrPerformCalls / this.nMinNumberOfFrames;\n\n\t\t// okay, so now, the decision is easy:\n\t\t//\n\t\t// If the fraction of time elapsed is smaller than the\n\t\t// number of calls required to be performed, then we calc\n\t\t// the position on the animation range according to\n\t\t// elapsed time. That is, we're so to say ahead of time.\n\t\t//\n\t\t// In contrary, if the fraction of time elapsed is larger,\n\t\t// then we're lagging, and we thus calc the position on\n\t\t// the animation time line according to the fraction of\n\t\t// calls performed. Thus, the animation is forced to slow\n\t\t// down, and take the required minimal number of steps,\n\t\t// sufficiently equally distributed across the animation\n\t\t// time line.\n\n\t\tif (nFractionElapsedTime < nFractionRequiredCalls) {\n\t\t\treturn 0.0;\n\t\t} else {\n\t\t\t// lag global time, so all other animations lag, too:\n\t\t\treturn (\n\t\t\t\t(nFractionElapsedTime - nFractionRequiredCalls) *\n\t\t\t\tthis.nMinSimpleDuration\n\t\t\t);\n\t\t}\n\t}\n\n\tpublic perform() {\n\t\t// call base class, for start() calls and end handling\n\t\tif (!super.perform()) return false; // done, we're ended\n\n\t\t// get relative animation position\n\t\tconst nCurrElapsedTime = this.aTimer.getElapsedTime();\n\t\tlet nT = nCurrElapsedTime / this.nMinSimpleDuration;\n\n\t\t// one of the stop criteria reached?\n\n\t\t// will be set to true below, if one of the termination criteria matched.\n\t\tlet bActivityEnding = false;\n\n\t\tif (this.isRepeatCountValid()) {\n\t\t\t// Finite duration case\n\n\t\t\t// When we've autoreverse on, the repeat count doubles\n\t\t\tconst nRepeatCount = this.getRepeatCount();\n\t\t\tconst nEffectiveRepeat = this.isAutoReverse()\n\t\t\t\t? 2.0 * nRepeatCount\n\t\t\t\t: nRepeatCount;\n\n\t\t\t// time (or frame count) elapsed?\n\t\t\tif (nEffectiveRepeat <= nT) {\n\t\t\t\t// Ok done for now. Will not exit right here,\n\t\t\t\t// to give animation the chance to render the last\n\t\t\t\t// frame below\n\t\t\t\tbActivityEnding = true;\n\n\t\t\t\t// clamp animation to max permissible value\n\t\t\t\tnT = nEffectiveRepeat;\n\t\t\t}\n\t\t}\n\n\t\t// need to do auto-reverse?\n\n\t\tlet nRepeats;\n\t\tlet nRelativeSimpleTime;\n\t\t// TODO(Q3): Refactor this mess\n\t\tif (this.isAutoReverse()) {\n\t\t\t// divert active duration into repeat and\n\t\t\t// fractional part.\n\t\t\tnRepeats = Math.floor(nT);\n\t\t\tconst nFractionalActiveDuration = nT - nRepeats;\n\n\t\t\t// for auto-reverse, map ranges [1,2), [3,4), ...\n\t\t\t// to ranges [0,1), [1,2), etc.\n\t\t\tif (nRepeats % 2) {\n\t\t\t\t// we're in an odd range, reverse sweep\n\t\t\t\tnRelativeSimpleTime = 1.0 - nFractionalActiveDuration;\n\t\t\t} else {\n\t\t\t\t// we're in an even range, pass on as is\n\t\t\t\tnRelativeSimpleTime = nFractionalActiveDuration;\n\t\t\t}\n\n\t\t\t// effective repeat count for autoreverse is half of\n\t\t\t// the input time's value (each run of an autoreverse\n\t\t\t// cycle is half of a repeat)\n\t\t\tnRepeats /= 2;\n\t\t} else {\n\t\t\t// determine repeat\n\n\t\t\t// calc simple time and number of repeats from nT\n\t\t\t// Now, that's easy, since the fractional part of\n\t\t\t// nT gives the relative simple time, and the\n\t\t\t// integer part the number of full repeats:\n\t\t\tnRepeats = Math.floor(nT);\n\t\t\tnRelativeSimpleTime = nT - nRepeats;\n\n\t\t\t// clamp repeats to max permissible value (maRepeats.getValue() - 1.0)\n\t\t\tif (this.isRepeatCountValid() && nRepeats >= this.getRepeatCount()) {\n\t\t\t\t// Note that this code here only gets\n\t\t\t\t// triggered if this.nRepeats is an\n\t\t\t\t// _integer_. Otherwise, nRepeats will never\n\t\t\t\t// reach nor exceed\n\t\t\t\t// maRepeats.getValue(). Thus, the code below\n\t\t\t\t// does not need to handle cases of fractional\n\t\t\t\t// repeats, and can always assume that a full\n\t\t\t\t// animation run has ended (with\n\t\t\t\t// nRelativeSimpleTime = 1.0 for\n\t\t\t\t// non-autoreversed activities).\n\n\t\t\t\t// with modf, nRelativeSimpleTime will never\n\t\t\t\t// become 1.0, since nRepeats is incremented and\n\t\t\t\t// nRelativeSimpleTime set to 0.0 then.\n\t\t\t\t//\n\t\t\t\t// For the animation to reach its final value,\n\t\t\t\t// nRepeats must although become this.nRepeats - 1.0,\n\t\t\t\t// and nRelativeSimpleTime = 1.0.\n\t\t\t\tnRelativeSimpleTime = 1.0;\n\t\t\t\tnRepeats -= 1.0;\n\t\t\t}\n\t\t}\n\n\t\t// actually perform something\n\n\t\tthis.simplePerform(nRelativeSimpleTime, nRepeats);\n\n\t\t// delayed endActivity() call from end condition check\n\t\t// below. Issued after the simplePerform() call above, to\n\t\t// give animations the chance to correctly reach the\n\t\t// animation end value, without spurious bail-outs because\n\t\t// of isActive() returning false.\n\t\tif (bActivityEnding) this.endActivity();\n\n\t\t// one more frame successfully performed\n\t\t++this.nCurrPerformCalls;\n\n\t\treturn this.isActive();\n\t}\n\n\tprotected simplePerform(nSimpleTime: number, nRepeatCount: number): void {\n\t\t// empty body\n\t}\n}\n"]}