{"version":3,"file":"Path.Transform.Util.js","sourceRoot":"","sources":["../../../../../../../../../../../TanhX/online/browser/src/layer/vector/Path.Transform.Util.js"],"names":[],"mappings":"AAAA,gCAAgC;AAChC,gBAAgB;AAEhB;;;GAGG;AACH,CAAC,CAAC,aAAa,GAAG,EAAE,CAAC;AAErB;;;;;;;GAOG;AACH,CAAC,CAAC,aAAa,CAAC,WAAW,GAAG,UAAS,KAAK,EAAE,KAAK,EAAE,MAAM;IAC1D,IAAI,KAAK,GAAG,CAAC,GAAG,MAAM,GAAG,KAAK,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;IACjD,OAAO,IAAI,CAAC,CAAC,KAAK,CACjB,KAAK,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,GAAG,KAAK,EACrC,KAAK,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,GAAG,KAAK,CACrC,CAAC;AACH,CAAC,CAAC;AAGF;;GAEG;AACH,CAAC,CAAC,aAAa,CAAC,KAAK,GAAG;IACvB,IAAI,CAAC,GAAG,CAAC,CAAC;IACV,IAAI,GAAG,EAAE,GAAG,CAAC;IACb,IAAI,GAAG,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC;IAEvB,SAAS,QAAQ,CAAC,MAAM;QACvB,OAAO,MAAM,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,iBAAiB,CAAC;IACrE,CAAC;IAED,+DAA+D;IAC/D,kCAAkC;IAClC,IAAI,MAAM,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC;IAE1B,OAAO,GAAG,EAAE;QACX,GAAG,GAAG,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC;QACrB,KAAK,GAAG,IAAI,GAAG,EAAE;YAChB,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,GAAG,EAAE,GAAG,CAAC,EAAE;gBACpD,SAAS;aACT;YAED,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC;YAEf,IAAI,QAAQ,CAAC,GAAG,CAAC,IAAI,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,EAAE;gBAC3C,MAAM,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,GAAG,CAAC,EAAE,GAAG,CAAC,CAAC;aAC/C;iBAAM;gBACN,MAAM,CAAC,GAAG,CAAC,GAAG,GAAG,CAAC;aAClB;SACD;KACD;IACD,OAAO,MAAM,CAAC;AACf,CAAC,CAAC","sourcesContent":["/* -*- js-indent-level: 8 -*- */\n/* global app */\n\n/**\n * @namespace\n * @type {Object}\n */\nL.PathTransform = {};\n\n/**\n * Point on the line segment or its extension\n *\n * @param  {L.Point} start\n * @param  {L.Point} final\n * @param  {Number}  distPx\n * @return {L.Point}\n */\nL.PathTransform.pointOnLine = function(start, final, distPx) {\n\tvar ratio = 1 + distPx / start.distanceTo(final);\n\treturn new L.Point(\n\t\tstart.x + (final.x - start.x) * ratio,\n\t\tstart.y + (final.y - start.y) * ratio\n\t);\n};\n\n\n/**\n * Deep merge objects.\n */\nL.PathTransform.merge = function() {\n\tvar i = 1;\n\tvar key, val;\n\tvar obj = arguments[i];\n\n\tfunction isObject(object) {\n\t\treturn Object.prototype.toString.call(object) === '[object Object]';\n\t}\n\n\t// make sure we don't modify source element and it's properties\n\t// objects are passed by reference\n\tvar target = arguments[0];\n\n\twhile (obj) {\n\t\tobj = arguments[i++];\n\t\tfor (key in obj) {\n\t\t\tif (!Object.prototype.hasOwnProperty.call(obj, key)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tval = obj[key];\n\n\t\t\tif (isObject(val) && isObject(target[key])) {\n\t\t\t\ttarget[key] = app.util.merge(target[key], val);\n\t\t\t} else {\n\t\t\t\ttarget[key] = val;\n\t\t\t}\n\t\t}\n\t}\n\treturn target;\n};\n"]}