{"version":3,"file":"CLineUtil.js","sourceRoot":"","sources":["../../../../../../../../../../../TanhX/online/browser/src/layer/vector/CLineUtil.ts"],"names":[],"mappings":"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","sourcesContent":["// @ts-strict-ignore\n/* -*- js-indent-level: 8 -*- */\n/*\n * CLineUtil contains different utility functions for line segments\n * and polylines (clipping, simplification, distances, etc.)\n */\n\nnamespace CLineUtil {\n\n\tvar _lastCode: number = 0;\n\n\t// Simplify polyline with vertex reduction and Douglas-Peucker simplification.\n\t// Improves rendering performance dramatically by lessening the number of points to draw.\n\n\texport function simplify(points: Array<cool.Point>, tolerance: number): Array<cool.Point> {\n\t\tif (!tolerance || !points.length) {\n\t\t\treturn points.slice();\n\t\t}\n\n\t\tvar sqTolerance = tolerance * tolerance;\n\n\t\t// stage 1: vertex reduction\n\t\tpoints = _reducePoints(points, sqTolerance);\n\n\t\t// stage 2: Douglas-Peucker simplification\n\t\tpoints = _simplifyDP(points, sqTolerance);\n\n\t\treturn points;\n\t}\n\n\t// distance from a point to a segment between two points\n\tfunction pointToSegmentDistance(p: cool.Point, p1: cool.Point, p2: cool.Point) {\n\t\treturn Math.sqrt(_sqDistToClosestPointOnSegment(p, p1, p2));\n\t}\n\n\t// Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm\n\tfunction _simplifyDP(points: Array<cool.Point>, sqTolerance: number): Array<cool.Point> {\n\n\t\tvar len = points.length;\n\t\tvar markers = typeof Uint8Array !== undefined + '' ? new Uint8Array(len) : Array<boolean>(len);\n\n\t\tmarkers[0] = markers[len - 1] = true;\n\n\t\t_simplifyDPStep(points, markers, sqTolerance, 0, len - 1);\n\n\t\tvar i: number;\n\t\tvar newPoints = Array<cool.Point>();\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (markers[i]) {\n\t\t\t\tnewPoints.push(points[i]);\n\t\t\t}\n\t\t}\n\n\t\treturn newPoints;\n\t}\n\n\tfunction _simplifyDPStep(points: Array<cool.Point>, markers: Uint8Array | Array<boolean>, sqTolerance: number, first: number, last: number) {\n\n\t\tvar maxSqDist = 0;\n\t\tvar index: number;\n\t\tvar i: number;\n\t\tvar sqDist: number;\n\n\t\tfor (i = first + 1; i <= last - 1; i++) {\n\t\t\tsqDist = _sqDistToClosestPointOnSegment(points[i], points[first], points[last]);\n\n\t\t\tif (sqDist > maxSqDist) {\n\t\t\t\tindex = i;\n\t\t\t\tmaxSqDist = sqDist;\n\t\t\t}\n\t\t}\n\n\t\tif (maxSqDist > sqTolerance) {\n\t\t\tmarkers[index] = true;\n\n\t\t\t_simplifyDPStep(points, markers, sqTolerance, first, index);\n\t\t\t_simplifyDPStep(points, markers, sqTolerance, index, last);\n\t\t}\n\t}\n\n\t// reduce points that are too close to each other to a single point\n\tfunction _reducePoints(points: Array<cool.Point>, sqTolerance: number): Array<cool.Point> {\n\t\tvar reducedPoints = [points[0]];\n\n\t\tfor (var i = 1, prev = 0, len = points.length; i < len; i++) {\n\t\t\tif (_sqDist(points[i], points[prev]) > sqTolerance) {\n\t\t\t\treducedPoints.push(points[i]);\n\t\t\t\tprev = i;\n\t\t\t}\n\t\t}\n\t\tif (prev < len - 1) {\n\t\t\treducedPoints.push(points[len - 1]);\n\t\t}\n\t\treturn reducedPoints;\n\t}\n\n\t// Cohen-Sutherland line clipping algorithm.\n\t// Used to avoid rendering parts of a polyline that are not currently visible.\n\n\texport function clipSegment(a: cool.Point, b: cool.Point, bounds: cool.Bounds, useLastCode: boolean, round: boolean): Array<cool.Point> {\n\t\tvar codeA = useLastCode ? _lastCode : _getBitCode(a, bounds);\n\t\tvar codeB = _getBitCode(b, bounds);\n\t\tvar codeOut: number;\n\t\tvar p: cool.Point;\n\t\tvar newCode: number;\n\n\t\t// save 2nd code to avoid calculating it on the next segment\n\t\t_lastCode = codeB;\n\n\t\twhile (true) {\n\t\t\t// if a,b is inside the clip window (trivial accept)\n\t\t\tif (!(codeA | codeB)) {\n\t\t\t\treturn [a, b];\n\t\t\t\t// if a,b is outside the clip window (trivial reject)\n\t\t\t} else if (codeA & codeB) {\n\t\t\t\treturn [];\n\t\t\t\t// other cases\n\t\t\t} else {\n\t\t\t\tcodeOut = codeA || codeB;\n\t\t\t\tp = _getEdgeIntersection(a, b, codeOut, bounds, round);\n\t\t\t\tnewCode = _getBitCode(p, bounds);\n\n\t\t\t\tif (codeOut === codeA) {\n\t\t\t\t\ta = p;\n\t\t\t\t\tcodeA = newCode;\n\t\t\t\t} else {\n\t\t\t\t\tb = p;\n\t\t\t\t\tcodeB = newCode;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction _getEdgeIntersection(a: cool.Point, b: cool.Point, code: number, bounds: cool.Bounds, round: boolean): cool.Point {\n\t\tvar dx = b.x - a.x;\n\t\tvar dy = b.y - a.y;\n\t\tvar min = bounds.min;\n\t\tvar max = bounds.max;\n\t\tvar x: number;\n\t\tvar y: number;\n\n\t\tif (code & 8) { // top\n\t\t\tx = a.x + dx * (max.y - a.y) / dy;\n\t\t\ty = max.y;\n\n\t\t} else if (code & 4) { // bottom\n\t\t\tx = a.x + dx * (min.y - a.y) / dy;\n\t\t\ty = min.y;\n\n\t\t} else if (code & 2) { // right\n\t\t\tx = max.x;\n\t\t\ty = a.y + dy * (max.x - a.x) / dx;\n\n\t\t} else if (code & 1) { // left\n\t\t\tx = min.x;\n\t\t\ty = a.y + dy * (min.x - a.x) / dx;\n\t\t}\n\n\t\treturn new cool.Point(x, y, round);\n\t}\n\n\tfunction _getBitCode(p: cool.Point, bounds: cool.Bounds): number {\n\t\tvar code = 0;\n\n\t\tif (p.x < bounds.min.x) { // left\n\t\t\tcode |= 1;\n\t\t} else if (p.x > bounds.max.x) { // right\n\t\t\tcode |= 2;\n\t\t}\n\n\t\tif (p.y < bounds.min.y) { // bottom\n\t\t\tcode |= 4;\n\t\t} else if (p.y > bounds.max.y) { // top\n\t\t\tcode |= 8;\n\t\t}\n\n\t\treturn code;\n\t}\n\n\t// square distance (to avoid unnecessary Math.sqrt calls)\n\tfunction _sqDist(p1: cool.Point, p2: cool.Point): number {\n\t\tvar dx = p2.x - p1.x;\n\t\tvar dy = p2.y - p1.y;\n\t\treturn dx * dx + dy * dy;\n\t}\n\n\t// return closest point on segment or distance to that point\n\tfunction _sqClosestPointOnSegment(p: cool.Point, p1: cool.Point, p2: cool.Point): cool.Point {\n\t\tvar x = p1.x;\n\t\tvar y = p1.y;\n\t\tvar dx = p2.x - x;\n\t\tvar dy = p2.y - y;\n\t\tvar dot = dx * dx + dy * dy;\n\t\tvar t: number;\n\n\t\tif (dot > 0) {\n\t\t\tt = ((p.x - x) * dx + (p.y - y) * dy) / dot;\n\n\t\t\tif (t > 1) {\n\t\t\t\tx = p2.x;\n\t\t\t\ty = p2.y;\n\t\t\t} else if (t > 0) {\n\t\t\t\tx += dx * t;\n\t\t\t\ty += dy * t;\n\t\t\t}\n\t\t}\n\n\t\treturn new cool.Point(x, y);\n\t}\n\n\t// returns distance to closest point on segment.\n\tfunction _sqDistToClosestPointOnSegment(p: cool.Point, p1: cool.Point, p2: cool.Point): number {\n\t\treturn _sqDist(_sqClosestPointOnSegment(p, p1, p2), p);\n\t}\n}\n"]}