{"version":3,"file":"CPolygon.js","sourceRoot":"","sources":["../../../../../../../../../../../TanhX/online/browser/src/layer/vector/CPolygon.ts"],"names":[],"mappings":"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","sourcesContent":["// @ts-strict-ignore\n/* -*- js-indent-level: 8 -*- */\n\n/*\n * CPolygon implements polygon vector layer (closed polyline with a fill inside).\n * This is used to draw overlays like cell-selections (self or views) with multi-selection support.\n */\n\nclass CPolygon extends CPolyline {\n\n\tconstructor(pointSet: CPointSet, options: any) {\n\t\tsuper(pointSet, options);\n\t\tif (options.fill === undefined)\n\t\t\tthis.fill = true;\n\t}\n\n\tgetCenter(): cool.Point {\n\t\tvar i: number;\n\t\tvar j: number;\n\t\tvar len: number;\n\t\tvar p1: cool.Point;\n\t\tvar p2: cool.Point;\n\t\tvar f: number;\n\t\tvar area: number;\n\t\tvar x: number;\n\t\tvar y: number;\n\t\tvar points = this.rings[0];\n\n\t\t// polygon centroid algorithm; only uses the first ring if there are multiple\n\n\t\tarea = x = y = 0;\n\n\t\tfor (i = 0, len = points.length, j = len - 1; i < len; j = i++) {\n\t\t\tp1 = points[i];\n\t\t\tp2 = points[j];\n\n\t\t\tf = p1.y * p2.x - p2.y * p1.x;\n\t\t\tx += (p1.x + p2.x) * f;\n\t\t\ty += (p1.y + p2.y) * f;\n\t\t\tarea += f * 3;\n\t\t}\n\n\t\treturn new cool.Point(x / area, y / area);\n\t}\n\n\tupdatePath(paintArea?: cool.Bounds, paneBounds?: cool.Bounds, freezePane?: { freezeX: boolean, freezeY: boolean }) {\n\n\t\tthis.parts = this.rings;\n\n\t\t// remove last point in the rings/parts if it equals first one\n\t\tfor (var i = 0, len = this.rings.length; i < len; i++) {\n\t\t\tvar ring = this.rings[i];\n\t\t\tvar ringlen = ring.length;\n\t\t\tif (ring.length >= 2 && ring[0].equals(ring[ringlen - 1])) {\n\t\t\t\tring.pop();\n\t\t\t}\n\t\t}\n\n\t\tthis.simplifyPoints();\n\t\tthis.renderer.updatePoly(this, true /* closed? */, paintArea, paneBounds, freezePane);\n\t}\n\n\tanyRingBoundContains(corePxPoint: cool.Point): boolean {\n\t\tfor (var i = 0; i < this.rings.length; ++i) {\n\t\t\tvar ringBound = new cool.Bounds(undefined);\n\t\t\tvar ring = this.rings[i];\n\t\t\tfor (var pointIdx = 0; pointIdx < ring.length; ++pointIdx) {\n\t\t\t\tringBound.extend(ring[pointIdx]);\n\t\t\t}\n\n\t\t\tif (ring.length && ringBound.contains(corePxPoint))\n\t\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n}\n"]}