{"version":3,"file":"CPointSet.js","sourceRoot":"","sources":["../../../../../../../../../../../TanhX/online/browser/src/layer/vector/CPointSet.ts"],"names":[],"mappings":"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","sourcesContent":["// @ts-strict-ignore\n/* -*- js-indent-level: 8 -*- */\n\n/*\n * CPointSet is a recursive datastructure used to represent a set of points connected by lines.\n * This is used by CPolyline and hence CPolygon classes to represent set of disconnected/disjoint\n * open/closed polygons respectively.\n */\n\nclass CPointSet {\n\tprivate points: Array<cool.Point>;\n\tprivate pointSets: Array<CPointSet>;\n\n\tstatic fromPointArray(array: Array<cool.Point>) {\n\t\tvar ps = new CPointSet();\n\t\tps.points = array;\n\t\treturn ps;\n\t}\n\n\tstatic fromSetArray(array: Array<CPointSet>) {\n\t\tvar ps = new CPointSet();\n\t\tps.pointSets = array;\n\t\treturn ps;\n\t}\n\n\tstatic fromBounds(bounds: cool.Bounds) {\n\t\tvar ps = new CPointSet();\n\t\tps.points = [\n\t\t\tbounds.getTopLeft(),\n\t\t\tbounds.getTopRight(),\n\t\t\tbounds.getBottomRight(),\n\t\t\tbounds.getBottomLeft()];\n\t\treturn ps;\n\t}\n\n\tisFlat(): boolean {\n\t\treturn this.points !== undefined;\n\t}\n\n\tempty(): boolean {\n\t\treturn (\n\t\t\t(this.points === undefined && this.pointSets === undefined) ||\n\t\t\t(this.pointSets === undefined && this.points.length == 0));\n\t}\n\n\tgetPointArray(): Array<cool.Point> {\n\t\treturn this.points;\n\t}\n\n\tgetSetArray(): Array<CPointSet> {\n\t\treturn this.pointSets;\n\t}\n\n\tsetPointArray(array: Array<cool.Point>) {\n\t\tthis.points = array;\n\t\tthis.pointSets = undefined;\n\t}\n\n\tsetSetArray(array: Array<CPointSet>) {\n\t\tthis.points = undefined;\n\t\tthis.pointSets = array;\n\t}\n\n\t// This is used in CCellSelection to draw multiple polygons based on a \"inner\" point-set\n\t// where we need to apply an additive offset to each point in the pointSet w.r.t each polygon's centroid.\n\tapplyOffset(offset: cool.Point, centroidSymmetry: boolean = false, preRound: boolean = true) {\n\t\tCPointSet.applyOffsetImpl(this, offset, centroidSymmetry, preRound);\n\t}\n\n\tclone(): CPointSet {\n\t\treturn CPointSet.cloneImpl(this);\n\t}\n\n\tprivate static cloneImpl(source: CPointSet): CPointSet {\n\t\tconst newPointSet = new CPointSet();\n\n\t\tif (source.points) {\n\t\t\tnewPointSet.points = [];\n\t\t\tsource.points.forEach(function(point) {\n\t\t\t\tnewPointSet.points.push(point.clone());\n\t\t\t});\n\t\t} else if (source.pointSets) {\n\t\t\tnewPointSet.pointSets = [];\n\t\t\tsource.pointSets.forEach(function (childPointSet) {\n\t\t\t\tconst clonedChild = CPointSet.cloneImpl(childPointSet);\n\t\t\t\tnewPointSet.pointSets.push(clonedChild);\n\t\t\t});\n\t\t}\n\n\t\treturn newPointSet;\n\t}\n\n\tprivate static applyOffsetImpl(pointSet: CPointSet, offset: cool.Point, centroidSymmetry: boolean, preRound: boolean) {\n\t\tif (pointSet.empty())\n\t\t\treturn;\n\n\t\tif (pointSet.isFlat()) {\n\t\t\tconst refPoint = new cool.Point(Infinity, Infinity);\n\t\t\tif (centroidSymmetry) {\n\t\t\t\trefPoint.x = 0;\n\t\t\t\trefPoint.y = 0;\n\t\t\t\t// Compute centroid for this set of points.\n\t\t\t\tpointSet.points.forEach(function (point) {\n\t\t\t\t\trefPoint._add(point);\n\t\t\t\t});\n\t\t\t\trefPoint._divideBy(pointSet.points.length);\n\t\t\t}\n\t\t\tpointSet.points.forEach(function (point, index) {\n\t\t\t\tif (preRound)\n\t\t\t\t\tpointSet.points[index]._round();\n\n\t\t\t\tif (point.x < refPoint.x)\n\t\t\t\t\tpointSet.points[index].x -= offset.x;\n\t\t\t\telse\n\t\t\t\t\tpointSet.points[index].x += offset.x;\n\n\t\t\t\tif (point.y < refPoint.y)\n\t\t\t\t\tpointSet.points[index].y -= offset.y;\n\t\t\t\telse\n\t\t\t\t\tpointSet.points[index].y += offset.y;\n\t\t\t});\n\n\t\t\treturn;\n\t\t}\n\n\t\t// not flat so recurse.\n\t\tpointSet.pointSets.forEach(function(childPointSet) {\n\t\t\tCPointSet.applyOffsetImpl(childPointSet, offset, centroidSymmetry, preRound);\n\t\t});\n\t}\n}\n"]}