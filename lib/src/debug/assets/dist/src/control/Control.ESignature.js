/*
 * Copyright the Collabora Online contributors.
 *
 * SPDX-License-Identifier: MPL-2.0
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var cool;
(function (cool) {
    /**
     * Provides electronic signing with document hashes for PDF files.
     */
    var ESignature = /** @class */ (function () {
        function ESignature(url, clientId) {
            // Timestamp of the hash extraction
            this.signatureTime = 0;
            // Identifier of the document on the eIDEasy side
            this.docId = '';
            // The popup window we opened.
            this.popup = null;
            this.showSignaturesOnNextUpdate = false;
            // Tracks when the signature popup is open.
            this.signInProgress = false;
            this.url = url;
            this.clientId = clientId;
            app.map.on('commandvalues', this.onCommandValues.bind(this));
            app.map.on('commandresult', this.onCommandResult.bind(this));
            if (!ESignature.countryNames) {
                ESignature.countryNames = {
                    // Generated by scripts/countries.py
                    AD: _('Andorra'),
                    AE: _('United Arab Emirates'),
                    AL: _('Albania'),
                    AM: _('Armenia'),
                    AR: _('Argentina'),
                    AT: _('Austria'),
                    AU: _('Australia'),
                    AX: _('Ã…land Islands'),
                    AZ: _('Azerbaijan'),
                    BA: _('Bosnia and Herzegovina'),
                    BE: _('Belgium'),
                    BG: _('Bulgaria'),
                    BR: _('Brazil'),
                    BY: _('Belarus'),
                    CA: _('Canada'),
                    CH: _('Switzerland'),
                    CL: _('Chile'),
                    CN: _('China'),
                    CY: _('Cyprus'),
                    CZ: _('Czech Republic'),
                    DE: _('Germany'),
                    DK: _('Denmark'),
                    EE: _('Estonia'),
                    ES: _('Spain'),
                    FI: _('Finland'),
                    FR: _('France'),
                    GB: _('United Kingdom'),
                    GE: _('Georgia'),
                    GG: _('Guernsey'),
                    GR: _('Greece'),
                    HR: _('Croatia'),
                    HU: _('Hungary'),
                    ID: _('Indonesia'),
                    IE: _('Ireland'),
                    IL: _('Israel'),
                    IN: _('India'),
                    IS: _('Iceland'),
                    IT: _('Italy'),
                    JP: _('Japan'),
                    KE: _('Kenya'),
                    KR: _('South Korea'),
                    KZ: _('Kazakhstan'),
                    LI: _('Liechtenstein'),
                    LT: _('Lithuania'),
                    LU: _('Luxembourg'),
                    LV: _('Latvia'),
                    MC: _('Monaco'),
                    MD: _('Moldova, Republic of'),
                    ME: _('Montenegro'),
                    MK: _('North Macedonia, Republic of'),
                    MT: _('Malta'),
                    MX: _('Mexico'),
                    NL: _('Netherlands'),
                    NO: _('Norway'),
                    NZ: _('New Zealand'),
                    PH: _('Philippines'),
                    PL: _('Poland'),
                    PT: _('Portugal'),
                    QA: _('Qatar'),
                    RO: _('Romania'),
                    RS: _('Serbia'),
                    RU: _('Russian Federation'),
                    SA: _('Saudi Arabia'),
                    SE: _('Sweden'),
                    SG: _('Singapore'),
                    SI: _('Slovenia'),
                    SK: _('Slovakia'),
                    SM: _('San Marino'),
                    TR: _('Turkey'),
                    TW: _('Taiwan, Province of China'),
                    UA: _('Ukraine'),
                    US: _('United States of America'),
                    VA: _('Holy See (Vatican City State)'),
                    XK: _('Kosovo'),
                    ZA: _('South Africa'),
                };
            }
        }
        ESignature.prototype.insert = function () {
            // Step 1: extract the document hash.
            app.socket.sendMessage('commandvalues command=.uno:Signature');
        };
        // Handles the result of dispatched UNO commands
        ESignature.prototype.onCommandResult = function (event) {
            if (event.commandName == '.uno:PrepareSignature') {
                var response = event.result;
                this.handleSendHashResponse(event.success, response);
            }
            else if (event.commandName == '.uno:DownloadSignature') {
                var response = event.result;
                this.handleReceiveSignatureResponse(response);
            }
        };
        // Handles the command values response for .uno:Signature
        ESignature.prototype.onCommandValues = function (event) {
            if (event.commandName != '.uno:Signature') {
                return;
            }
            var signatureResponse = event.commandValues;
            // Save this, we'll need it for the serialize step.
            this.signatureTime = signatureResponse.signatureTime;
            var digest = signatureResponse.digest;
            // Step 2: send the hash, get a document ID.
            var redirectUrl = window.makeHttpUrl('/cool/signature');
            var documentName = (document.querySelector('#document-name-input'));
            var fileName = documentName.value;
            var body = {
                client_id: this.clientId,
                // Create a PKCS#7 binary signature
                container_type: 'cades',
                files: [
                    {
                        // Actual file name appears during 2FA
                        fileName: fileName,
                        mimeType: 'application/pdf',
                        fileContent: digest,
                    },
                ],
                // Learn about possible providers
                return_available_methods: true,
                // Learn about which provider is available in which country
                return_method_configs: true,
                signature_redirect: redirectUrl,
                // Automatic file download will not happen after signing
                nodownload: true,
            };
            var args = {
                body: body,
            };
            app.map.sendUnoCommand('.uno:PrepareSignature', args);
        };
        // Handles the 'send hash' response JSON
        ESignature.prototype.handleSendHashResponse = function (ok, response) {
            if (!ok) {
                app.console.log('/api/signatures/prepare-files-for-signing failed: ' +
                    response.message);
                return;
            }
            this.docId = response.doc_id;
            var availableProviderIDs = response.available_methods;
            var availableProviderConfigs = response.method_configs;
            var countries = this.createCountryList(availableProviderConfigs);
            var providers = this.createProviders(availableProviderIDs, availableProviderConfigs);
            var dialog = JSDialog.eSignatureDialog(countries, providers);
            // Providers can be in-context or redirect-based.  Most real-world providers
            // are redirect-based, set the only tested non-in-context provider as
            // preferred.
            var defaultProviderId = window.prefs.get('eSignatureDefaultProviderId', 'd-trust-sign-me-qes-signature');
            dialog.setDefaultProviderId(defaultProviderId);
            // Set the country for the default provider as preferred.
            var defaultCountryCode = window.prefs.get('eSignatureDefaultCountryCode', 'DE');
            dialog.setDefaultCountryCode(defaultCountryCode);
            dialog.open();
        };
        // Handles the selected provider from the dialog
        ESignature.prototype.handleSelectedProvider = function (countryCode, providerId) {
            app.console.log('attempting to esign using the "' + providerId + '" provider');
            window.prefs.set('eSignatureDefaultCountryCode', countryCode);
            window.prefs.set('eSignatureDefaultProviderId', providerId);
            var url = this.url + '/single-method-signature';
            url += '?client_id=' + this.clientId;
            url += '&doc_id=' + this.docId;
            url += '&method=' + providerId;
            url += '&country=' + countryCode;
            var lang = window.coolParams.get('lang');
            if (lang) {
                // Two letter ISO 639-1 language code is wanted, but it seems to
                // accept our xx-YY version.
                url += '&lang=' + lang;
            }
            var features = 'popup';
            features += ', left=' + window.screen.width / 4;
            features += ', top=' + window.screen.height / 4;
            features += ', width=' + window.screen.width / 2;
            features += ', height=' + window.screen.height / 2;
            // Step 3: sign the hash.
            this.signInProgress = true;
            this.popup = window.open(url, '_blank', features);
            var message = _('The document is being signed and will be availably shortly');
            app.map.fire('showbusy', { label: message });
            // If our window would be closed before the popup, then close the popup as
            // well.
            window.addEventListener('beforeunload', this.closePopup.bind(this));
        };
        ESignature.prototype.closePopup = function () {
            try {
                window.removeEventListener('beforeunload', this.closePopup.bind(this));
                if (this.popup) {
                    this.popup.close();
                }
            }
            catch (error) {
                app.console.log('failed to close the signing popup: ' + error);
                return false;
            }
            return true;
        };
        // Handles the 'sign hash' response
        ESignature.prototype.handleSigned = function (response) {
            app.map.fire('hidebusy');
            if (response.type != 'SUCCESS') {
                app.console.log('failed to sign: ' + response.error);
                return;
            }
            if (!this.closePopup()) {
                return;
            }
            this.signInProgress = false;
            // Step 4: fetch the signature.
            var body = {
                client_id: this.clientId,
                doc_id: this.docId,
            };
            var args = {
                body: body,
            };
            app.map.sendUnoCommand('.uno:DownloadSignature', args, /*force=*/ true);
        };
        // Handles the 'receive signature' response JSON
        ESignature.prototype.handleReceiveSignatureResponse = function (response) {
            if (response.status != 'OK') {
                app.console.log('received signature status is not OK: ' + response.status);
                return;
            }
            // Step 5: serialize the signature.
            this.showSignaturesOnNextUpdate = true;
            var args = {
                SignatureTime: {
                    type: 'string',
                    value: String(this.signatureTime),
                },
                SignatureValue: {
                    type: 'string',
                    value: response.signed_file_contents,
                },
            };
            app.map.sendUnoCommand('.uno:Signature', args, /*force=*/ true);
        };
        // Turns a list of provider IDs into a list of signature providers
        ESignature.prototype.createProviders = function (providerIds, providerConfigs) {
            return providerIds.map(function (id) {
                var providerName = ESignature.providerNames[id];
                if (!providerName) {
                    app.console.log('failed to find a human-readable name for provider "' + id + '"');
                    providerName = id;
                }
                var providerConfig = providerConfigs.find(function (i) { return i.action_type == id; });
                var countryCodes = [];
                if (providerConfig) {
                    countryCodes = providerConfig.supported_countries;
                }
                return {
                    action_type: id,
                    name: providerName,
                    countryCodes: countryCodes,
                };
            });
        };
        ESignature.prototype.createCountryList = function (availableProviderConfigs) {
            var e_1, _a, e_2, _b;
            var codes = new Array();
            try {
                for (var availableProviderConfigs_1 = __values(availableProviderConfigs), availableProviderConfigs_1_1 = availableProviderConfigs_1.next(); !availableProviderConfigs_1_1.done; availableProviderConfigs_1_1 = availableProviderConfigs_1.next()) {
                    var config = availableProviderConfigs_1_1.value;
                    try {
                        for (var _c = (e_2 = void 0, __values(config.supported_countries)), _d = _c.next(); !_d.done; _d = _c.next()) {
                            var code = _d.value;
                            codes.push(code);
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (availableProviderConfigs_1_1 && !availableProviderConfigs_1_1.done && (_a = availableProviderConfigs_1.return)) _a.call(availableProviderConfigs_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            codes = __spreadArray([], __read(new Set(codes)), false);
            return codes.map(function (code) {
                var countryName = ESignature.countryNames
                    ? ESignature.countryNames[code]
                    : null;
                if (countryName) {
                    return { code: code, name: countryName };
                }
                app.console.log('failed to find a human-readable name for country "' + code + '"');
                return { code: code, name: code };
            });
        };
        // Provider ID to name map.
        ESignature.providerNames = {
            // The /api/client-config API would provide this, but having the data here
            // saves us from fetching the same data every time for every user.
            'id-signature': 'Estonian ID card',
            'mid-signature': 'Estonian Mobile-ID',
            'lt-mid-signature': 'Lithuanian Mobile-ID',
            'smart-id-signature': 'Smart-ID',
            'be-id-signature': 'Belgian ID card',
            'lt-id-signature': 'Lithuanian ID card',
            'lv-id-signature': 'Latvian ID card',
            'lv-eparaksts-mobile-signature': 'Latvian eParaksts Mobile',
            'fi-id-signature': 'Finnish ID card',
            'at-handy-signatur-signature': 'Austrian Handy-Signatur',
            'evrotrust-signature': 'Evrotrust',
            'd-trust-sign-me-qes-signature': 'D-Trust sign-me',
            'certeurope-usb-token-signature': 'CertEurope USB token',
            'certsign-usb-token-signature': 'certSIGN USB token',
            'zealid-signature': 'ZealID app',
            'audkenni-qes-signature': 'Audkenni',
            'simply-sign-qes-signature': 'SimplySign',
            'halcom-qes-signature': 'Halcom',
            'hr-id-signature': 'Croatian ID Card',
            'uanataca-qes-signature': 'Uanataca',
            'itsme-qes-signature': 'Itsme',
            'harica-qes-signature': 'Harica',
            'lt-id-qes-signature': 'LT ID',
            'trust-asia-signature': 'TrustAsia',
            'buypass-qes-signature': 'Buypass',
            'cert-store-qes-signature': 'Local Certificate',
            'fi-ftn-intesi-adv-signature': 'Finnish Trust Network / Luottamusverkosto',
            'cz-id-signature': 'Czech ID Card',
            'es-lleida-advanced-signature': 'Lleida',
            'serpro-id-advanced-signature': 'SerproID',
        };
        // Country code to name map
        ESignature.countryNames = null;
        return ESignature;
    }());
    cool.ESignature = ESignature;
})(cool || (cool = {}));
L.Control.ESignature = cool.ESignature;
L.control.eSignature = function (url, clientId) {
    return new L.Control.ESignature(url, clientId);
};
//# sourceMappingURL=Control.ESignature.js.map